1).# RLE-сжатие
# RLE-сжатие – один из самых простых методов сжатия строки, основанный на сокращении подстрок,
# состоящих из одинаковых символов. Сжатие осуществляется следующим образом:
 
# Строка разбивается на минимальное количество подстрок, состоящих из одинаковых символов. Например, abbcaaa превращается в строки a, bb, c, aaa.
# Каждая из полученных строк превращается в строку, состоящую из числа и буквы. 
# Числом является количество повторений символа в этой строке, буква берётся из первого символа обрабатываемой строки. 
# Число не добавляется, если количество символов в строке равно единице. Из предыдущего массива строк мы получаем a, 2b, c, 3a.
# Затем полученные строки конкатенируются в исходном порядке. В рассмотренном примере в итоге получим a2bc3a.
# Формат ввода
# В первой строке входного файла записана строка s, состоящая из строчных букв латинского алфавита и цифр (1≤|s|≤1000000).
# Гарантируется, что существует такая непустая строка t, из которой RLE-сжатием получается строка s.
# Также гарантируется, что в строке tне было больше 1000000000 одинаковых подряд идущих символов.
# В следующей строке дано количество запросов q(1≤q≤100000).
# Каждая из следующих qстрок содержит два числа li и ri(1≤li≤ri≤|t|) — параметры запросов.

# Формат вывода
# Выведите q чисел, каждое в отдельной строке — ответы на запросы в том порядке, в котором запросы были заданы во входных данных.

# Ввод	  Вывод	    Ввод	       Вывод
# a2bc3a	  6	   x1000000000yz	   11
#  2	      3	       2	            9
#  17		             2          1000000001	
#  35		           5938493       15938493	
import itertools
import re

with open ('input.txt', 'r') as file:
	kk =  file.readlines()


string = kk[0].rstrip()

nums = re.findall(r'\d+', string)

for i in nums:
	string = re.sub(i, string[string.index(i[-1])+1]*(int(i)-1), string)

liss = list(string)
def rle(line):
    for char, same in itertools.groupby(line):
        count = sum(1 for _ in same)
        yield char if count == 1 else str(count)+char

for i in kk[2:]:
	i_nums = re.findall(r'\d+', i)
	a = int(i_nums[0])-1
	b = int(i_nums[1])

	line = liss[a:b]

	print(len(''.join(rle(line))))

# 2).Создайте список из случайных чисел. 
# Найдите номер его последнего локального максимума 
# (локальный максимум — это элемент, который больше любого из своих соседей).

# import random
# n = int(input('Введите количество элементов: '))
# list = [random.randint(-50, 50) for item in range(n)]
# print(list)
# local_max = 0
# for i in range(1, len(list) - 1):
#     if list[i] > list[i - 1] and list[i] > list[i + 1]:
#         local_max = list[i]
# print(local_max)
# print(i)

# 3).Создайте список из случайных чисел. Найдите максимальное количество его одинаковых элементов.

# import random
# n = int(input('Введите количество элементов: '))
# list = [random.randint(-50, 50) for item in range(n)]
# print(list)
# list.sort()
# print(list)

# 4).Создайте список из случайных чисел. Найдите второй максимум.
# a = [1, 2, 3] # Первый максимум == 3, второй == 2

# n = int(input('Введите количество элементов: '))
# list = [random.randint(-50, 50) for item in range(n)]
# print(list)
# list.sort()
# print(list[-2])
